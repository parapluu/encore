import Math(absi)
import Collections.Mutable.OrderedSet
import Random

active class Main
  def main(opts : [String]) : unit
    var success = false
    if |opts| == 4 && opts(1).eq("-pa") then
      val nopt = opts(2).to_int()
      val kopt = opts(3).to_int()
      match (nopt, kopt) with
        case (Just(n), Just(k)) =>
          success = true
          this.preferential_attachment(n, k)
        end
      end
    else if |opts| == 3 && opts(1).eq("-sub") then
      val dopt = opts(2).to_int()
      match dopt with 
        case Just(d) =>  
          success = true
          this.sub_graph(d)    
        end
      end
    end
    
    if not success then
      this.usage()
    end    
  end
  
  def usage() : unit
    println("Usage:")
    println("    GraphGen -pa n k")
    println("      generate a social network using preferential attachment")
    println("      n is the number of node, k is the number of new edges per node")
    println("    GraphGen -sub d")
    println("      generate a 'subtraction graph' where d is the number of digits")
  end
  
  def sub_graph(digits : int) : unit
    val d = new DigitReverser(digits)
    repeat i <- pow(10, d) do
      this.out(i, absi(i - d.reverse(i)))
    end
  end
  
  def preferential_attachment(n : int, k : int) : unit
    val nodes = new [int](2 * n * k)
    val rand = new Random(5334) -- random seed
    var count = 0
       
    -- set up intial k nodes in ring
    if k > 1 then
      repeat i <- k do
        nodes(count) = i
        count += 1
        nodes(count) = (i + 1) % k
        count += 1
        this.out(i, (i + 1) % k)
      end
    else
      nodes(count) = 0
      count += 1
    end
    
    for i <- [k .. n] do  -- TODO: or n - 1   
      val others = new OrderedSet[int](fun (i : int, j : int) => i - j)
      repeat j <- k do
        others.add(nodes(rand.random(count)))
      end
    
      -- ITERATE OVER SET
      val iter = others.iter()
      while iter.has_next() do
        var other = iter.next()
        nodes(count) = i
        count += 1
        nodes(count) = other
        count += 1
        this.out(i, other)
      end
    end
  end
    
  def out(i : int, j : int) : unit
--      println("({}, {})", i ,j)
--      println("{}, {}", i ,j)
      println("{} -> {};", i ,j)
  end
end

local class DigitReverser
  val buff : [int]
  val size : int
  
  def init (size : int) : unit
    this.size = size
    this.buff = new [int](size)
  end
  
  def reverse(var inp : int) : int
    repeat i <- |this.buff| do
      this.buff(i) = inp % 10
      inp /= 10
    end
    var res = 0
    repeat i <- |this.buff| do
      res = res * 10 + this.buff(i)
    end
    res
  end
end

{-
import java.util.Set;
import java.util.HashSet;
import java.util.Random;

public class GraphGen {
    public static void main(String[] args) {
        int n = 1;
        int k = 1;

        if (args.length != 2) {
            System.err.println("Usage: java GraphGen number_of_nodes min_number_of_friends");
            System.exit(1);
        }
        
        try {
            n = Integer.parseInt(args[0]);
            k = Integer.parseInt(args[1]);
        } catch (NumberFormatException e) {
            System.err.println("Arguments must be an integer s");
            System.err.println("Usage: java GraphGen number_of_nodes min_number_of_friends");
            System.exit(1);
        }

        int[] nodes = new int[2 * n * k];
        Random rand = new Random();
        int count = 0;
       
        // set up intial k nodes in ring
        if (k > 1) {
            for (int i = 0; i < k; i++) {
                nodes[count++] = i;
                nodes[count++] = (i + 1) % k;
                out(i,(i + 1) % k);
            }
        } else {
            nodes[count++] = 0;
        }
        
        for (int i = k; i < n; i++) {
            Set<Integer> others = new HashSet<Integer>();
            for (int j = 0; j < k; j++) {
                others.add(nodes[rand.nextInt(count)]);
            }
            
            for (int other : others) {
                nodes[count++] = i;
                nodes[count++] = other;
                // only keep new edges
                out(i, other);
            }
        }
    }
    
    public static void out(int i, int j) {
        System.out.println("(" + i + "," + j +")");
    }
}

-}