{-# LANGUAGE MultiParamTypeClasses, TypeSynonymInstances, FlexibleInstances #-}

{-|

Translate a @ClassDecl@ (see "AST") to its @CCode@ (see "CCode.Main")
equivalent.

-}

module CodeGen.ClassDecl () where

import CodeGen.Typeclasses
import CodeGen.CCodeNames
import CodeGen.MethodDecl ()
import CodeGen.ClassTable
import CodeGen.Type
import CodeGen.Trace (traceVariable)

import CCode.Main
import CCode.PrettyCCode ()

import Data.List

import qualified AST.AST as A
import qualified Identifiers as ID
import qualified Types as Ty

instance Translatable A.ClassDecl (ClassTable -> CCode FIN) where
  translate cdecl ctable
      | A.isActive cdecl = translateActiveClass cdecl ctable
      | otherwise        = translatePassiveClass cdecl ctable

-- | Translates an active class into its C representation. Note
-- that there are additional declarations in the file generated by
-- "CodeGen.Header"
translateActiveClass cdecl@(A.Class{A.cname, A.cfields, A.cmethods}) ctable =
    Program $ Concat $
      (LocalInclude "header.h") :
      [traitMethodSelector ctable cdecl] ++
      [typeStructDecl] ++
      [runtimeTypeInitFunDecl cdecl] ++
      [tracefunDecl cdecl] ++
      methodImpls ++
      [dispatchfunDecl] ++
      [runtimeTypeDecl cname]
    where
      typeStructDecl :: CCode Toplevel
      typeStructDecl =
          let typeParams = Ty.getTypeParameters cname in
          StructDecl (AsType $ classTypeName cname) $
                     ((encoreActorT, Var "_enc__actor") :
                      (map (\ty -> (Ptr ponyTypeT, AsLval $ typeVarRefName ty)) typeParams ++
                         zip
                         (map (translate  . A.ftype) cfields)
                         (map (AsLval . fieldName . A.fname) cfields)))

      methodImpls = map methodImpl cmethods
          where
            methodImpl mdecl = translate mdecl cdecl ctable

      dispatchfunDecl :: CCode Toplevel
      dispatchfunDecl =
          (Function (Static void) (classDispatchName cname)
           ([(Ptr . Typ $ "pony_actor_t", Var "_a"),
             (Ptr . Typ $ "pony_msg_t", Var "_m")])
           (Seq [Assign (Decl (Ptr . AsType $ classTypeName cname, Var "this"))
                        (Cast (Ptr . AsType $ classTypeName cname) (Var "_a")),
                 (Switch (Var "_m" `Arrow` Nam "id")
                  (
                   taskDispatchClause :
                   (if (A.isMainClass cdecl)
                    then ponyMainClause :
                         (methodClauses $ filter ((/= ID.Name "main") . A.mname) cmethods)
                    else methodClauses $ cmethods
                   ))
                  (Statement $ Call (Nam "printf") [String "error, got invalid id: %zd", AsExpr $ (Var "_m") `Arrow` (Nam "id")]))]))
           where
             ponyMainClause =
                 (Nam "_ENC__MSG_MAIN",
                  Seq $ [Assign (Decl (Ptr $ Typ "pony_main_msg_t", Var "msg")) (Cast (Ptr $ Typ "pony_main_msg_t") (Var "_m")),
                         Statement $ Call ((methodImplName (Ty.refType "Main") (ID.Name "main")))
                                          [(Cast (Ptr $ Typ "_enc__active_Main_t") (Var "_a")),
                                           Call (Nam "array_from_array")
                                                [AsExpr $ (Var "msg") `Arrow` (Nam "argc"),
                                                 AsExpr $ Var "ENCORE_PRIMITIVE",
                                                 Cast (Ptr encoreArgT) $ (Var "msg") `Arrow` (Nam "argv")]]])

             methodClauses = concatMap methodClause

             methodClause m = (mthdDispatchClause m) :
                              if not (A.isStreamMethod m)
                              then [oneWaySendDispatchClause m]
                              else []

             -- explode _enc__Foo_bar_msg_t struct into variable names
             methodUnpackArguments :: A.MethodDecl -> CCode Ty -> [CCode Stat]
             methodUnpackArguments mdecl msgTypeName =
               zipWith unpack (A.mparams mdecl) [1..]
                 where
                   unpack :: A.ParamDecl -> Int -> CCode Stat
                   unpack A.Param{A.pname, A.ptype} n = (Assign (Decl (translate ptype, (argName pname))) ((Cast (msgTypeName) (Var "_m")) `Arrow` (Nam $ "f"++show n)))

             -- TODO: include GC
             -- TODO: pack in encore_arg_t the task, infering its type
             taskDispatchClause :: (CCode Name, CCode Stat)
             taskDispatchClause =
               let tmp = Var "task_tmp"
                   taskRunner = Statement $ Call (Nam "task_runner") [Var "_task"]
                   decl = Assign (Decl (encoreArgT, tmp)) taskRunner
                   futureFulfil = Statement $ Call (Nam "future_fulfil") [AsExpr $ Var "_fut", AsExpr tmp]
                   taskFree = Statement $ Call (Nam "task_free") [AsExpr $ Var "_task"]
                   traceFuture = Statement $ Call (Nam "pony_traceobject") [Var "_fut", futureTypeRecName `Dot` Nam "trace"]
                   traceTask = Statement $ Call (Nam "pony_traceobject") [Var "_task", AsLval $ Nam "NULL"]
               in
               (taskMsgId, Seq $ [unpackFuture, unpackTask, decl] ++
                                 [Embed $ "",
                                  Embed $ "// --- GC on receiving ----------------------------------------",
                                  Statement $ Call (Nam "pony_gc_recv") ([] :: [CCode Expr]),
                                  traceFuture,
                                  traceTask,
                                  Embed $ "//---You need to trace the task env and task dependencies---",
                                  Statement $ Call (Nam "pony_recv_done") ([] :: [CCode Expr]),
                                  Embed $ "// --- GC on sending ----------------------------------------",
                                  Embed $ ""]++
                           [futureFulfil, taskFree])


             mthdDispatchClause mdecl@(A.Method{A.mname, A.mparams, A.mtype})  =
                (futMsgId cname mname,
                 Seq (unpackFuture :
                      ((methodUnpackArguments mdecl (Ptr . AsType $ futMsgTypeName cname mname)) ++
                      gcRecv mparams (Statement $ Call (Nam "pony_traceobject") [Var "_fut", futureTypeRecName `Dot` Nam "trace"]) ++
                      [Statement $ Call (Nam "future_fulfil")
                                        [AsExpr $ Var "_fut",
                                         asEncoreArgT (translate mtype)
                                             (Call (methodImplName cname mname)
                                             ((Var $ "this") :
                                             (map (argName . A.pname) mparams)))]])))
             mthdDispatchClause mdecl@(A.StreamMethod{A.mname, A.mparams})  =
                (futMsgId cname mname,
                 Seq (unpackFuture :
                      ((methodUnpackArguments mdecl (Ptr . AsType $ futMsgTypeName cname mname)) ++
                      gcRecv mparams (Statement $ Call (Nam "pony_traceobject") [Var "_fut", futureTypeRecName `Dot` Nam "trace"]) ++
                      [Statement $ Call (methodImplName cname mname)
                                         ((Var $ "this") :
                                          (Var $ "_fut") :
                                          (map (argName . A.pname) mparams))])))

             oneWaySendDispatchClause mdecl@A.Method{A.mname, A.mparams} =
                (oneWayMsgId cname mname,
                 Seq ((methodUnpackArguments mdecl (Ptr . AsType $ oneWayMsgTypeName cname mname)) ++
                     gcRecv mparams (Comm "Not tracing the future in a oneWay send") ++
                     [Statement $ Call (methodImplName cname mname) ((Var $ "this") : (map (argName . A.pname) mparams))]))

             unpackFuture = let lval = Decl (Ptr (Typ "future_t"), Var "_fut")
                                rval = (Cast (Ptr $ encMsgT) (Var "_m")) `Arrow` (Nam "_fut")
                            in Assign lval rval

             unpackTask = let lval = Decl (task, Var "_task")
                              rval = (Cast (Ptr taskMsgT) (Var "_m")) `Arrow` (Nam "_task")
                          in Assign lval rval

             gcRecv ps futTrace = [Embed $ "",
                                   Embed $ "// --- GC on receive ----------------------------------------",
                                   Statement $ Call (Nam "pony_gc_recv") ([] :: [CCode Expr])] ++
                                  (map traceEachParam ps) ++
                                  [futTrace,
                                   Statement $ Call (Nam "pony_recv_done") ([] :: [CCode Expr]),
                                   Embed $ "// --- GC on receive ----------------------------------------",
                                   Embed $ ""]

             traceEachParam A.Param{A.pname, A.ptype} =
               Statement $ traceVariable ptype $ argName pname

-- | Translates a passive class into its C representation. Note
-- that there are additional declarations (including the data
-- struct for instance variables) in the file generated by
-- "CodeGen.Header"
translatePassiveClass cdecl@(A.Class{A.cname, A.cfields, A.cmethods}) ctable =
    Program $ Concat $
      (LocalInclude "header.h") :
      [traitMethodSelector ctable cdecl] ++
      [runtimeTypeInitFunDecl cdecl] ++
      [tracefunDecl cdecl] ++
      methodImpls ++
      [dispatchfunDecl] ++
      [runtimeTypeDecl cname]
    where
      methodImpls = map methodDecl cmethods
          where
            methodDecl mdecl = translate mdecl cdecl ctable
      dispatchfunDecl =
          Function (Static void) (classDispatchName cname)
                   [(Ptr ponyActorT, Var "_a"),
                    (Ptr ponyMsgT, Var "_m")]
                   (Comm "Stub! Might be used when we have dynamic dispatch on passive classes")

traitMethodSelector :: ClassTable -> A.ClassDecl -> CCode Toplevel
traitMethodSelector ctable A.Class{A.cname, A.ccapability} =
  let
    retType = Static (Ptr void)
    fname = traitMethodSelectorName
    args = [(Typ "int" , Var "id")]
    cond = Var "id"
    traitTypes = Ty.typesFromCapability ccapability
    traitMethods = map (`lookupMethods` ctable) traitTypes
    cases = concat $ zipWith (traitCase cname) traitTypes traitMethods
    err = String "error, got invalid id: %d"
    defaultCase = Statement $ Call (Nam "printf") [err, AsExpr $ Var "id"]
    switch = Switch cond cases defaultCase
    body = Seq [ switch, Return Null ]
  in
    Function retType fname args body
  where
    traitCase :: Ty.Type -> Ty.Type -> [A.MethodDecl] ->
                 [(CCode Name, CCode Stat)]
    traitCase cname tname tmethods =
        let
            methodNames = map A.mname tmethods
            caseNames = map (oneWayMsgId tname) methodNames
            caseStmts = map (Return . methodImplName cname) methodNames
        in
          zip caseNames caseStmts

runtimeTypeInitFunDecl :: A.ClassDecl -> CCode Toplevel
runtimeTypeInitFunDecl A.Class{A.cname, A.cfields, A.cmethods} =
    Function void (runtimeTypeInitFnName cname)
                 [(Ptr . AsType $ classTypeName cname, Var "this"), (Embed "...", Embed "")]
                   (Seq $
                    (Statement $ Decl (Typ "va_list", Var "params")) :
                    (Statement $ Call (Nam "va_start") [Var "params", Var "this"]) :
                    map initRuntimeType typeParams ++
                    [Statement $ Call (Nam "va_end") [Var "params"]])
        where
          typeParams = Ty.getTypeParameters cname
          initRuntimeType ty =
              Assign (Var "this" `Arrow` typeVarRefName ty)
                     (Call (Nam "va_arg") [Var "params", Var "pony_type_t *"])

tracefunDecl :: A.ClassDecl -> CCode Toplevel
tracefunDecl A.Class{A.cname, A.cfields, A.cmethods} =
    case find ((== Ty.getId cname ++ "_trace") . show . A.mname) cmethods of
      Just mdecl@(A.Method{A.mbody, A.mname}) ->
          Function void (classTraceFnName cname)
                   [(Ptr void, Var "p")]
                   (Statement $ Call (methodImplName cname mname)
                                [Var "p"])
      Nothing ->
          Function void (classTraceFnName cname)
                   [(Ptr void, Var "p")]
                   (Seq $
                    (Assign (Decl (Ptr . AsType $ classTypeName cname, Var "this"))
                            (Var "p")) :
                     map (Statement . traceField) cfields)
    where
      traceField A.Field {A.ftype, A.fname} =
        let field = (Var "this") `Arrow` (fieldName fname)
        in traceVariable ftype field

runtimeTypeDecl cname =
    (AssignTL
     (Decl (Typ "pony_type_t", AsLval $ runtimeTypeName cname))
           (Record [AsExpr . AsLval $ classId cname,
                    Call (Nam "sizeof") [AsLval $ classTypeName cname],
                    Int 0,
                    Int 0,
                    AsExpr . AsLval $ (classTraceFnName cname),
                    Null,
                    Null,
                    AsExpr . AsLval $ classDispatchName cname,
                    Null,
                    Int 0,
                    Null,
                    Null,
                    Record [AsExpr . AsLval $ traitMethodSelectorName]
                    ]))
