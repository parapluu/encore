{-# LANGUAGE GADTs,FlexibleContexts #-}
{-|
Defines how things will be called in the CCode generated by CodeGen.hs
Provides mappings from class/method names to their C-name.

The purpose of this module is to

 - get one central place where identifiers in the generated code can be changed

 - ease following of good conventions (ie use @Ptr char@ instead of @Embed "char*"@)

-}

module CodeGen.CCodeNames where

import qualified Identifiers as ID
import Types as Ty
import CCode.Main
import Data.List

char :: CCode Ty
char = Typ "char"

int :: CCode Ty
int = Typ "int64_t"

uint :: CCode Ty
uint = Typ "uint64_t"

bool :: CCode Ty
bool = Typ "int64_t" -- For pony argument tag compatibility. Should be changed to something smaller

double :: CCode Ty
double = Typ "double"

void :: CCode Ty
void = Typ "void"

encore_actor_t :: CCode Ty
encore_actor_t = Typ "encore_actor_t"

pony_type_t :: CCode Ty
pony_type_t = Typ "pony_type_t"

pony_actor_t :: CCode Ty
pony_actor_t = Typ "pony_actor_t"

pony_actor_type_t :: CCode Ty
pony_actor_type_t = Typ "pony_actor_type_t"

encore_arg_t :: CCode Ty
encore_arg_t = Typ "encore_arg_t"

is_encore_arg_t :: CCode Ty -> Bool
is_encore_arg_t (Typ "encore_arg_t") = True
is_encore_arg_t _ = False

pony_msg_t :: CCode Ty
pony_msg_t = Typ "pony_msg_t"

enc_msg_t :: CCode Ty
enc_msg_t = Typ "encore_fut_msg_t"

task_msg_t = Typ "encore_task_msg_s"

enc_oneway_msg_t :: CCode Ty
enc_oneway_msg_t = Typ "encore_oneway_msg_t"

closure :: CCode Ty
closure = Ptr $ Typ "closure_t"

task :: CCode Ty
task = Ptr $ Typ "encore_task_s"

future :: CCode Ty
future = Ptr $ Typ "future_t"

stream :: CCode Ty
stream = Ptr $ Typ "stream_t"

array :: CCode Ty
array = Ptr $ Typ "array_t"

range :: CCode Ty
range = Ptr $ Typ "struct range_t"

unit :: CCode Lval
unit = Embed "UNIT"

encore_name :: String -> String -> String
encore_name kind name =
  let
    non_emptys = filter (not . null) ["_enc_", kind, name]
  in
    concat $ intersperse "_" non_emptys

self_type_field :: CCode Name
self_type_field = Nam $ encore_name "self_type" ""

-- | each method is implemented as a function with a `this`
-- pointer. This is the name of that function
method_impl_name :: Ty.Type -> ID.Name -> CCode Name
method_impl_name clazz mname =
    Nam $ encore_name "method" $ (Ty.getId clazz) ++ "_" ++ (show mname)

arg_name :: ID.Name -> CCode Lval
arg_name name =
    Var $ encore_name "arg" (show name)

field_name :: ID.Name -> CCode Name
field_name name =
    Nam $ encore_name "field" (show name)

global_closure_name :: ID.Name -> CCode Name
global_closure_name funname =
    Nam $ encore_name "closure" (show funname)

global_function_name :: ID.Name -> CCode Name
global_function_name funname =
    Nam $ encore_name "global_fun" (show funname)

closure_fun_name :: String -> CCode Name
closure_fun_name name =
    Nam $ encore_name "closure_fun" name

closure_env_name :: String -> CCode Name
closure_env_name name =
    Nam $ encore_name "env" name

closure_trace_name :: String -> CCode Name
closure_trace_name name =
    Nam $ encore_name "trace" name

task_function_name :: String -> CCode Name
task_function_name name =
    Nam $ encore_name "task" name

task_env_name :: String -> CCode Name
task_env_name name =
    Nam $ encore_name "task_env" name

task_dependency_name :: String -> CCode Name
task_dependency_name name =
    Nam $ encore_name "task_dep" name

task_trace_name :: String -> CCode Name
task_trace_name name =
    Nam $ encore_name "task_trace" name

stream_handle :: CCode Lval
stream_handle = Var "_stream"

type_var_ref_name :: Ty.Type -> CCode Name
type_var_ref_name ty =
    Nam $ encore_name "type" (show ty)

class_id :: Ty.Type -> CCode Name
class_id ty =
    Nam $ encore_name "ID" (Ty.getId ty)

ref_type_id :: Ty.Type -> CCode Name
ref_type_id ty =
    Nam $ encore_name "ID" (Ty.getId ty)

trait_method_selector_name = Nam "trait_method_selector"

-- | each class, in C, provides a dispatch function that dispatches
-- messages to the right method calls. This is the name of that
-- function.
class_dispatch_name :: Ty.Type -> CCode Name
class_dispatch_name clazz =
    Nam $ encore_name "dispatch" (Ty.getId clazz)

class_trace_fn_name :: Ty.Type -> CCode Name
class_trace_fn_name clazz =
    Nam $ encore_name "trace" (Ty.getId clazz)

runtime_type_init_fn_name :: Ty.Type -> CCode Name
runtime_type_init_fn_name clazz =
    Nam $ encore_name "type_init" (Ty.getId clazz)

fut_msg_type_name :: Ty.Type -> ID.Name -> CCode Name
fut_msg_type_name cls mname =
    Nam $ encore_name "fut_msg" ((Ty.getId cls) ++ "_" ++ show mname ++ "_t")

one_way_msg_type_name :: Ty.Type -> ID.Name -> CCode Name
one_way_msg_type_name cls mname =
    Nam $ encore_name "oneway_msg" ((Ty.getId cls) ++ "_" ++ show mname ++ "_t")

-- | for each method, there's a corresponding message, this is its name
fut_msg_id :: Ty.Type -> ID.Name -> CCode Name
fut_msg_id ref mname =
    Nam $ "_ENC__FUT_MSG_" ++ Ty.getId ref ++ "_" ++ show mname

task_msg_id :: CCode Name
task_msg_id = Nam "_ENC__MSG_TASK"

one_way_msg_id :: Ty.Type -> ID.Name -> CCode Name
one_way_msg_id cls mname =
    Nam $ "_ENC__ONEWAY_MSG_" ++ Ty.getId cls ++ "_" ++ show mname

type_name_prefix :: Ty.Type -> String
type_name_prefix ref
    | Ty.isActiveClassType ref =
        encore_name "active" $ Ty.getId ref
    | Ty.isPassiveClassType ref =
        encore_name "passive" $ Ty.getId ref
    | Ty.isTraitType ref =
        encore_name "trait" $ Ty.getId ref
    | otherwise = error $ "type_name_prefix Type '" ++ show ref ++
                          "' isnt reference type!"

ref_type_name :: Ty.Type -> CCode Name
ref_type_name ref = Nam $ (type_name_prefix ref) ++ "_t"

class_type_name :: Ty.Type -> CCode Name
class_type_name ref = Nam $ (type_name_prefix ref) ++ "_t"

runtime_type_name :: Ty.Type -> CCode Name
runtime_type_name ref = Nam $ (type_name_prefix ref) ++ "_type"

future_trace_fn :: CCode Name
future_trace_fn = Nam "future_trace"

closure_trace_fn :: CCode Name
closure_trace_fn = Nam "closure_trace"

array_trace_fn :: CCode Name
array_trace_fn = Nam "array_trace"

stream_trace_fn :: CCode Name
stream_trace_fn = Nam "stream_trace"

future_type_rec_name :: CCode Name
future_type_rec_name = Nam $ "future_type"

closure_type_rec_name :: CCode Name
closure_type_rec_name = Nam $ "closure_type"

array_type_rec_name :: CCode Name
array_type_rec_name = Nam $ "array_type"

range_type_rec_name :: CCode Name
range_type_rec_name = Nam $ "range_type"
