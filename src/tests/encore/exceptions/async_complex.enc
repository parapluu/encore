exception Exception1(RuntimeException)
exception Exception2(Exception1)

active class Messenger
  def trycatch(suspend_ : bool) : bool
    -- returns success of trycatch
    try
      if suspend_ then this.suspend() end
      this.throw_("RuntimeException", suspend_)
      false
    catch e : RuntimeException
      true
    end
  end
  def trycatch_otherfut(m : Messenger, suspend_:bool, await_ : bool) : Fut[bool]
    if suspend_ then this.suspend() end
    var fut = m ! trycatch(suspend_)
    if await_ then await(fut) end
    fut
  end
  def trycatch_other(m : Messenger, suspend_ : bool) : bool
    if suspend_ then this.suspend() end
    var fut = m ! trycatch(suspend_)
    await(fut)
    get(fut)   
  end

  def throw_(exc : String, suspend_ : bool) : bool
    if suspend_ then this.suspend() end
    if exc.eq("Exception1") then
      throw Exception1
    else if exc.eq("Exception2") then
      throw Exception2
    else if exc.eq("RuntimeException") then
      throw RuntimeException
    else
      println("BAD EXCEPTION STRING! \"{}\"", exc)
    end
    false
  end
  def throw_otherfut(m : Messenger, exc : String, suspend_ : bool, await_ : bool) : Fut[bool]
    if suspend_ then this.suspend() end
    var fut = m ! throw_(exc, suspend_)
    if await_ then await(fut) end
    fut
  end
  def throw_other(m : Messenger, exc : String, suspend_ : bool) : bool
    try
      if suspend_ then this.suspend() end
      var fut = m ! throw_(exc, suspend_)
      await(fut)
      get(fut)
      false
    catch e : RuntimeException
      e.type.eq(exc) -- Return true if exception type is as expected
    end
  end

  def succeed(x : int, suspend_ : bool) : int
    if suspend_ then this.suspend() end
    x
  end
  def succeed_otherfut(m : Messenger, x : int, suspend_ : bool) : Fut[int]
    if suspend_ then this.suspend() end
    var fut = m ! succeed(x, suspend_)
    fut
  end
  def succeed_other(m : Messenger, x : int, suspend_ : bool) : bool
    if suspend_ then this.suspend() end
    var fut = m ! succeed(x, suspend_)
    await(fut)
    get(fut) == x
  end

  def interaction1(n : int, method : String) : bool
    -- Creates list of messengers which will message each other to run some method.
    -- O(n^2) calls (everyone calls everyone)
    var m = create_n_messengers(n)
    var s = true -- success variable

    repeat i <- |m| do
      repeat j <- |m| do
        if i != j then
          if method.eq("trycatch_other") then
            var f = m(i) ! trycatch_other(m(j), false)
            await(f)
            s = s && get(f)
          else if method.eq("trycatch_otherfut") then
            var f = m(i) ! trycatch_otherfut(m(j), false, false)
            await(f)
          else if method.eq("throw_other") then
            var f = m(i) ! throw_other(m(j), "Exception1", false)
            await(f)
            s = s && get(f)
          else if method.eq("throw_otherfut") then
            var f = m(i) ! throw_otherfut(m(j), "Exception1", false, false)
            await(f)
            try
              get(get(f))
              s = false
            catch
              s = s && true
            end
          else if method.eq("succeed_other") then
            var f = m(i) ! succeed_other(m(j), i, false)
            await(f)
            s = s && get(f)
          end

        end
      end
    end

    s
  end

  def interaction2(n : int, max_recursion : int) : bool
    -- Creates list of messengers which interact according to some pattern.
    --
    -- Precondition: n >= 4
    -- Args:
    --   n              messengers to create
    --   max_recursion  allowed nr of recursive calls to this function(`n` will not be used)
    --
    -- max_rescursion decreases on each call
    assertTrue(n >= 4)
  
    var m = create_n_messengers(n)
  
    -- success variable
    var s = true
    
    repeat i <- |m|-1 do
      -- creating some bools to use in interactions
      var b1 = if i%3 == 0 then true else false end
      var b2 = if i%5 == 0 then true else false end
      var b3 = if i%7 == 0 then true else false end
      var b4 = if i%9 == 0 then true else false end
  
      -- grabbing target messengers
      var m1 = m(i % |m|)
      var m2 = m((i+1) % |m|)
      var m3 = m((i-1+|m|) % |m|) -- add '|m|' since '%' can return negative values
      var m4 = m((i*2) % |m|)
  
      -- doing actual interactions
      var f1 = m1 ! succeed(i, b1)
      var f2 = m1 ! throw_other(m2, "Exception1", b2)
      var f3 = m1 ! trycatch_other(m3, b3)
      var f4 = m1 ! succeed_other(m4, i, b1)
      var f5 = m1 ! throw_otherfut(m2, "Exception2", b3, b4)
      
      -- maybe suspend this actor
      if b1 then this.suspend() end
  
      -- possibly doing a recursive call to this function 
      var recurse = (max_recursion > 0) && (i%5 == 0)
      var recursion_n = (i+4)%30
      if recurse then
        m1 ! interaction2(recursion_n, max_recursion-1)
      end

      -- maybe suspend this actor
      if b2 then this.suspend() end
      -- check result from futures (int)
      await(f1)
      s = s && (get(f1) == i)
      -- check results from futures (bools)
      await(f2)
      s = s && get(f2)
      await(f3)
      s = s && get(f3) 
      await(f4)
      s = s && get(f4) 
      -- check results from futures (exceptional), only check for some indexes
      if b1 then
        try
          await(f5)
          get(get(f5))
          s = false
        catch e : RuntimeException
          s = s && e.type.eq("Exception2")
        end
      end

    end

    -- return whether successful or not
    s
  end

end

fun create_n_messengers(n : int) : [Messenger]
  var m = new [Messenger](n)
  repeat i <- |m| do
    m(i) = new Messenger()
  end
  m
end

fun test_interaction1() : unit
  var m = new Messenger()
  var n = 100
  var b1 = m ! interaction1(n,"trycatch_other")
  await(b1)
  var b2 = m ! interaction1(n,"throw_other")
  await(b2)
  var b3 = m ! interaction1(n,"succeed_other")
  await(b3)
  var b4 = m ! interaction1(n,"trycatch_otherfut")
  await(b4)
  var b5 = m ! interaction1(n,"throw_otherfut")
  await(b5)
  println("trycatch_other:{}, throw_other:{}, succeed_other:{}, trycatch_otherfut:{}, throw_otherfut:{}", get(b1), get(b2), get(b3), get(b4), get(b5))
end

fun test_interaction2() : unit
  var m = new Messenger()
  var n = 10
  var b = m ! interaction2(n,0)
  println(string_from_bool(get(b)))
end


active class Main
  def main(args : [String]) : unit
    test_interaction1()
    -- test_interaction2() -- TODO: Test fails, first fix async_complex_FAILS.enc
  end
end
