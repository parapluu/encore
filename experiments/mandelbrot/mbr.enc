

{-
		Draws the mandelbrot set from  -1.5-i to 1.5+i on a N by N thing
		Pipe the output to lol.txt and then run the plot.py python script to
		generate a pictures

-}


class Main
  def main() : void
    let 
      N = 50 : int					  
      argc = embed int argc; end
      argv1 = embed int atoi(argv[1]); end
      plot = null : PlotList
    in{
        plot = new PlotList(argv1);
        plot.computeSet(10);
        plot.debugPrint()
    }

{-			
  def make_lame(N : int) : void
    let
      x_max = 1.5
      x_min = -1*1.5
      y_max = 1.0
      y_min = -1*1.0
      x = 0.0
      y = 0.0
      dx = 0.0
      dy = 0.0
      iterations = 100
      step = 0
      lol = new Line
    in {
      dx = (x_max - x_min) / N;
      dy = (y_max - y_min) / N;
      x = x_min;
      y = y_min;
      print("{}\n",iterations);
      print("{}\n",N);
      while (y < y_max) {
	  lol = new Line(step,"",N,iterations);
      get lol.compute(x_min,x_max,y);
        
		
        y = y+dy;
	   step = step + 1;
      };
    }
-}

passive class PlotList
    size : int
    first : Node
    
    def init(size : int) : void{
        this.first = null;
        this.size = size
    }
    
    def computeSet(iterations : int) : void{
        let
	        x_max = 1.5
	        x_min = -1*1.5
	        y_max = 1.0
	        y_min = -1*1.0
	        x = 0.0
	        y = 0.0
	        dx = 0.0
	        dy = 0.0
	        step = 0
	        lol = new Line
        in {
	        dx = (x_max - x_min) / this.size;
	        dy = (y_max - y_min) / this.size;
	        x = x_min;
	        y = y_min;
	        while (y < y_max) {
	            this.first = new Node(this.first, this.size, iterations, x_min, x_max, y);
	            y = y+dy;
	            step = step + 1;
	        };
        }
    }
    
    def debugPrint() : void
        let
            next = this.first
        in
            while (next != null){
                next.debugPrint();
                print "";
                next = next.getNextNode();
            }
        
            
    
    --def outputPBM(file_name : string) : void
        

passive class Node{
    next : Node
    line : Line
    block : Fut void
    size : int
    
    def setNext(next : Node) : void
        this.next = next
        
    def getNextNode() : Node
        this.next
    
    def init(next : Node, size : int, iterations : int, x_start : real, x_end : real , y_start : real) : void{
        this.size = size;                                                                          
        this.line = new Line(size, iterations);
        this.next = next;
        this.block = this.line.compute(x_start,x_end,y_start);
    }
    
    def debugPrint() : void
        let
            array = get this.line.getArray()
            i = 0
        in
            while(i < this.size){
                print("{},",array.read(i));
                i = i + 1;
            }
            
                        
        
        

}
        
        
		
--This ugly class corresponds to one row of the mandelbrot plot.
class Line
  array : IntArray
  width : int
  max_iterations : int
  done : bool
	
  def init(width : int, max_iterations : int) : void {
    this.array = new IntArray(width);
    this.width = width;
    this.max_iterations = max_iterations;
    this.done = false;
  }
    
  def getDone() : bool
    this.done
	
  def compute(x_start : real, x_end : real , y_start : real) : void 
    let
      cx = x_start
      cy = y_start
      dx = 0.0
      x = 0.0
      y = 0.0
      iteration = 0
      step = 0
      xtemp = 0.0
      i = 0
      member = 0
    in {
      dx = (x_end-x_start)/this.width;
      --print argc;
      while(step < this.width) {
	    x = 0.0;
        y = 0.0;
        iteration = 0;
        while ((x*x + y*y < 4.0) and (iteration < this.max_iterations)) {
            xtemp = x*x - y*y + cx;
            y = 2.0*x*y + cy;
	        x = xtemp;
            iteration = iteration + 1;
	     };
    
        if(iteration == this.max_iterations) then {
            member = 1
        }else{
            member = 0
        };
        this.array.write(step, member);
        cx = cx + dx;
        step = step+1;
      };
    }

    def  getArray() : IntArray
        this.array
	
		





passive class D

passive class IntArray
  slots: D
  size: int
  -- def IntArray_trace() : void
  --   embed void
  --     pony_trace(this->slots);
  --   end

  def init(size:int) : void
    embed void
      this->slots = pony_alloc(size * sizeof(int64_t));
      this->size = size;
    end

  def write(i:int, v:int) : void
    embed void
      ((int64_t*)this->slots)[i] = (int64_t)v;
    end

  def read(i:int) : int
    embed int
      (0 <= i && i < this->size) ? ((int64_t*)this->slots)[i] : 0;
    end
