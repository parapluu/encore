{-
	Plots the mandelbrot set from (-1.5-i) to (0.5+i) to a N*N
	.pbm file and dumps it to stdout.
	
	Every row of the image is computed asynchronously.

-}


class Main
  def main() : void
    let 
      N = 50 : int					  
      argc = embed int argc; end
      argv1 = embed int atoi(argv[1]); end
      plot = null : PlotList
    in{
        plot = new PlotList(argv1);
        plot.computeSet(50);
        --plot.debugPrint()
        plot.outputPBM()
        
    }


passive class PlotList
    size : int
    first : Node
    
    def init(size : int) : void{
        this.first = null;
        this.size = size
    }
    
    def computeSet(iterations : int) : void{
        let
	        x_max = 0.5
	        x_min = -1*1.5
	        y_max = 1.0
	        y_min = -1*1.0
	        x = 0.0
	        y = 0.0
	        dx = 0.0
	        dy = 0.0
	        step = 0
	        lol = new Line
        in {
	        dx = (x_max - x_min) / this.size;
	        dy = (y_max - y_min) / this.size;
	        x = x_min;
	        y = y_min;
	        while (y < y_max) {
	            this.first = new Node(this.first, this.size, iterations, x_min, x_max, y);
	            y = y+dy;
	            step = step + 1;
	        };
        }
    }
    
    def debugPrint() : void
        let
            next = this.first
        in
            while (next != null){
                next.debugPrint();
                print "";
                next = next.getNextNode();
            }
        
            
    
    def outputPBM() : void
        let
            next = this.first
        in{
            print("P4\n{} {}\n",this.size,this.size);
            while (next != null){
                next.packAndPrint();
                next = next.getNextNode();
            };
            print ""
        }
        

passive class Node{
    next : Node
    line : Line
    block : Fut void
    size : int
    
    def setNext(next : Node) : void
        this.next = next
        
    def getNextNode() : Node
        this.next
    
    def init(next : Node, size : int, iterations : int, x_start : real, x_end : real , y_start : real) : void{
        this.size = size;                                                                          
        this.line = new Line(size, iterations);
        this.line.compute(x_start,x_end,y_start); -- needed to get rid of type error.
        this.next = next;
      
    }
    
    def debugPrint() : void
        let
            array = get this.line.getArray()
            i = 0
        in
            while(i < this.size){
                print("{},",array.read(i));
                i = i + 1;
            }
            
    def packAndPrint() : void
        let
            array = get this.line.getArray()
            packed = 0
            i = 0
            j = 7
            member = 0
            shift = 0
            --aligned_size = size - (size % 8)
        in
            --aligned size = size - (size % 8);
            while(i < this.size){
                packed = 0;
                j = 7;
                while(j >= 0){
	                member = array.read(i);
	                packed = embed int (#{member} << #{j}) | #{packed}; end; 
	                i = i+1;
                    j = j-1
                };
                embed void
                    fwrite(&#{packed}, sizeof(char), 1, stdout);
                end
            }
        
}
        
class Line
  array : IntArray
  width : int
  max_iterations : int
  done : bool
	
  def init(width : int, max_iterations : int) : void {
    this.array = new IntArray(width);
    this.width = width;
    this.max_iterations = max_iterations;
    this.done = false;
  }
    
  def getDone() : bool
    this.done
	
  def compute(x_start : real, x_end : real , y_start : real) : void 
    let
      cx = x_start
      cy = y_start
      dx = 0.0
      x = 0.0
      y = 0.0
      iteration = 0
      step = 0
      xtemp = 0.0
      i = 0
      member = 0
    in {
      dx = (x_end-x_start)/this.width;
      --print argc;
      while(step < this.width) {
	    x = 0.0;
        y = 0.0;
        iteration = 0;
        while ((x*x + y*y < 4.0) and (iteration < this.max_iterations)) {
            xtemp = x*x - y*y + cx;
            y = 2.0*x*y + cy;
	        x = xtemp;
            iteration = iteration + 1;
	     };
    
        if(iteration == this.max_iterations) then {
            member = 1
        }else{
            member = 0
        };
        this.array.write(step, member);
        cx = cx + dx;
        step = step+1;
      };
    }

    def  getArray() : IntArray
        this.array


passive class D

passive class IntArray
  slots: D
  size: int
  -- def IntArray_trace() : void
  --   embed void
  --     pony_trace(this->slots);
  --   end

  def init(size:int) : void
    embed void
      this->slots = pony_alloc(size * sizeof(int64_t));
      this->size = size;
    end

  def write(i:int, v:int) : void
    embed void
      ((int64_t*)this->slots)[i] = (int64_t)v;
    end

  def read(i:int) : int
    embed int
      (0 <= i && i < this->size) ? ((int64_t*)this->slots)[i] : 0;
    end
