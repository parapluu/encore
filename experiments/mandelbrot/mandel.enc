


{-
		   Requests for docuemntation.
				How are formatting actually done.
				Are { neccesary
				Return type of init ???
				Type inference ??
				Scoping ?
				 Type casting ?
				 Basic synax (loops and such)
						 just the grammar is not cool
				 
-}


{-
		Draws the mandelbrot set from  -1.5-i to 1.5+i on a N by N thing

-}
class Main
	def main() : void{
		--print "computing mandelbrots like a boss ";
		let 
			N = 50 : int					  
			argc = embed int argc; end
			argv1 = embed int atoi(argv[1]); end
		

		in{
		
			print argc;
			
			this.make_lame(argv1);
            --this.array_dispatchy_cool(argv1, argc == 3)  
			--if(argc == 3) then{
					--get list.print(argv1);
			--}else{
			--		print "finished"
			--}
			
		}
					
	 }
			
	def make_lame(N : int) : void{
		let
			x_max = 1.5
			x_min = -1*1.5
			y_max = 1.0
			y_min = -1*1.0
			x = 0.0
			y = 0.0
			dx = 0.0
			dy = 0.0
			iterations = 100
			--list = new List()
			step = 0
			lol = new Line
				
		in{
			dx = (x_max - x_min) / N;
			dy = (y_max - y_min) / N;
			x = x_min;
			y = y_min;
			print("{}\n",iterations);
			print("{}\n",N);
			while (y < y_max){
					lol = new Line(step,"",N,iterations);
					get lol.compute(x_min,x_max,y);
					get lol.dump(true);								
					y = y+dy;
					step = step + 1;
			};
				
		}
	}
			
	def array_dispatchy_cool(N : int, dump : bool) : void{
		let
			line_array = new (Array<Line>)(N)
			x_max = 1.5
			x_min = -1*1.5
			y_max = 1.0
			y_min = -1*1.0
			x = 0.0
			y = 0.0
			dx = 0.0
			dy = 0.0
			iterations = 300
			step = 0
			line = new Line
		in{
			dx = (x_max - x_min) / N;
			dy = (y_max - y_min) / N;
			x = x_min;
			y = y_min;
			if(dump == false)then{
				print "quiet"
			};
			print("{}\n",iterations);
			print("{}\n",N);
			while (step < N){
					line = new Line(step,"",N,iterations);
					line_array.write(step, new (Array_Data<Line>)(line));
					line_array.read(step).v.compute(x_min,x_max,y);		
					y = y+dy;
					step = step + 1;
			};
			step = 0;
			if(dump == true) then{
				while (step < N){
						--line = new Line(step,"",N,iterations);
	                    get line_array.read(step).v.dump(true);
						step = step + 1;
				};
			}
			
	
	
		}
	}
				
		
		
passive class Monitor{
		finished : int
		threads : int
		
}

class Line{


	absolute_Y : int
	array : Array<int>
	file : string 
	width : int
	max_iterations : int
    done : bool
	
	def init(Y : int, file : string, width : int, max_iterations : int) : void{
		this.absolute_Y = Y;
		this.array = new (Array<int>)(width);
		this.file = file;
		this.width = width;
		this.max_iterations = max_iterations;
        this.done = false;

	}
    
    def getDone() : bool
        this.done
	
	def compute(x_start : real, x_end : real , y_start : real) : void{
		let
			cx = x_start
			cy = y_start
			dx = 0.0
			x = 0.0
			y = 0.0
			iteration = 0
			step = 0
			xtemp = 0.0
			i = 0
		in{
	
			dx = (x_end-x_start)/this.width;
			
			
			
			while(step < this.width){
				
				x = 0.0;
				y = 0.0;
				iteration = 0;
				while ((x*x + y*y < 4.0) and (iteration < this.max_iterations)){
					xtemp = x*x - y*y + cx;
					y = 2.0*x*y + cy;
					x = xtemp;
					iteration = iteration + 1;
				};
				
				{-
				if (iteration >= this.max_iterations) then{
					--is in set
					this.color = 1.0;
					1
				}else{
					--outside set
					this.color = 0.0;
					0
				};
				-}
				
				this.array.write(step, new (Array_Data<int>)(iteration));
				
				
				cx  =  cx + dx;
				step = step+1;
			
			};
	}
			
	}
	
	def dump( stdout : bool) : void{
			let
					i = 0
			in{
					if(stdout) then{
							print("{}",this.absolute_Y);
							while(i < this.width){
									print(",{}", this.array.read(i).v);
									i = i+1;
							};
							print "";
					}
			}
	}
	
}
		
		

		
		
		
		
		
























passive class Array_Data<t>
  v: t

  def init(v: t) : void
	this.v = v

passive class Array<t>
  slots: Array_Data<t>
  size: int

  def init(size:int) : void
	embed void
	  this->slots = pony_alloc(size * sizeof(void *));
	  this->size = size;
	end

  def write(i:int, v:Array_Data<t>) : void
	embed void
	  ((void **)this->slots)[i] = (void *)v;
	end

  def read(i:int) : (Array_Data<t>)
	embed (Array_Data<t>)
	  (0 <= i && i < this->size) ? ((void **)this->slots)[i] : NULL;
	end






















		
