module BuiltinExt
import Iter.Iter

-- This module, `BuiltinExt`, contains interfaces and implementations for
-- builtin types A builtin type can be given a method by adding it here. Each
-- type gets an associated trait, that contains the interface that an object of
-- the type shall implement. Alongside that trait, there is a family of
-- functions that represent the implementation of the methods. These functions
-- have the same interface as the methods, but an extra parameter for the 'this'
-- object in the first parameter position, and they all have a prefixed name.
-- For example, a function called `array_foo[t](arr : [t], i : int) : char`
-- defines the method `foo(i : int) : char` on arrays of type `t`. If you want
-- to use methods defined here in your own code, don't forget to
-- 'import BuiltinExt' in that file.

-- If you want to add new methods to an already supported built-in type, it's
-- enough to edit this file.

-- If you want to add support for new builtin types here, you'll have to modify
-- Typechecker/Util.hs, Typechecker/Typechecker.hs, and opt/Optimizer.hs

--------------------------------------------------------------------------------

fun array_foreach[t](arr : [t], f : t -> void) : void
  for x <- arr do
    f(x)
  end
end

fun array_map[t,v](arr : [t], f : t -> v) : [v]
  val ret = new [v](|arr|)
  for i <- [0 .. |arr|-1] do
    ret(i) = f((arr)(i))
  end
  ret
end

fun array_filter[t](arr : [t], f : t -> bool) : [t]
  val tmp = new [t](|arr|)
  var N = 0
  for i <- [0 .. |arr|-1] do
    if f(arr(i)) then
      tmp(N) = arr(i)
      N = N + 1
    end
  end
  if N < |arr| then
    val ret = new [t](N)
    for i <- [0 .. N-1] do
      ret(i) = tmp(i)
    end
    ret
  else
    tmp
  end
end

fun array_flatMap[t,v](arr : [t], f : t -> [v]) : [v]
  val tmps = new [[v]](|arr|)
  var totalSize = 0
  val N = |arr|
  for i <- [0 .. N-1] do
    tmps(i) = f(arr(i))
    totalSize = totalSize + |tmps(i)|
  end
  val ret = new [v](totalSize)
  var retCnt = 0
  -- These could be sped up, at an engineering cost, using memcpy
  for i <- [0 .. N-1] do
    val tmp = tmps(i)
    for j <- [0 .. |tmp|-1] do
      ret(retCnt) = tmp(j)
      retCnt = retCnt+1
    end
  end
  ret
end

fun array_iterator[t](arr : [t]) : Iter[t]
  new ArrayIter(arr)
end

trait ArrayExt[t]

  -- do something for each array cell
  require def foreach(f : t -> void) : void

  -- map over an array
  require def map[v](f : t -> v) : [v]

  -- filter an array
  require def filter(f : t -> bool) : [t]

  -- map each array element to a new array, and merge the results
  require def flatMap[v](f : t -> [v]) : [v]

  -- get an array iterator
  require def iterator() : Iter[t]
end

--------------------------------------------------------------------------------

trait MaybeExt[t]

  -- run on value, if exists
  require def foreach(f : t -> void)        : void

  -- return mapped Maybe, if there is a value
  require def map[v](f : t -> v)            : Maybe[v]

  -- return Nothing if already empty or f returns false
  require def filter(f : t -> bool)         : Maybe[t]

  -- return f(x) if non empty, Nothing otherwise
  require def flatMap[v](f : t -> Maybe[v]) : Maybe[v]
end

fun maybe_foreach[t](ox : Maybe[t], f : t -> void) : void
  match ox with
    case Just(x) => f(x)
    case _       => ()
  end
end

fun maybe_map[t,v](ox : Maybe[t], f : t -> v) : Maybe[v]
  match ox with
    case Just(x) => Just(f(x))
    case _       => Nothing
  end
end

fun maybe_filter[t](ox : Maybe[t], f : t -> bool) : Maybe[t]
  match ox with
    case Just(x) => if f(x) then ox else Nothing end
    case _       => Nothing
  end
end

fun maybe_flatMap[t,v](ox : Maybe[t], f : t -> Maybe[v]) : Maybe[v]
  match ox with
    case Just(x) => f(x)
    case _       => Nothing
  end
end
--------------------------------------------------------------------------------

trait FutExt[t]
  -- chain onto future
  require def foreach(f : t -> void)      : void

  -- chain onto future, return resulting future
  require def map[v](f : t -> v)          : Fut[v]

  -- return f(x), once 'this' is resolved
  require def flatMap[v](f : t -> Fut[v]) : Fut[v]
end

fun fut_foreach[t](fx : Fut[t], f : t -> void) : void
  fx ~~> f
end

fun fut_map[t,v](fx : Fut[t], f : t -> v) : Fut[v]
  fx ~~> f
end

fun fut_flatMap[t,v](fx : Fut[t], f : t -> Fut[v]) : Fut[v]
  -- once forward is working, this should do: ff ~~> (fun (f : t) => forward f)
  get(fx ~~> f)
end
