module ParT(
    empty,
    filter,
    bind,
    foreachp,
    aggregate,
    intersection,
    distinct,
    union,
    app,
    pairWith,
    groupJoin,
  )

fun empty[a]() : Par[a]
  EMBED (Par[a])
    new_par_empty(_ctx, runtimeType[0]);
  END
end

fun filter[a](fn : a -> bool, ps : Par[a]) : Par[a]
  join(ps >> fun (item : a) => if fn(item) then
                                 liftv(item)
                               else
                                 empty[a]()
                               end)
end

fun bind[a, b](fn : a -> Par[b], p : Par[a]) : Par[b]
  join(p >> fn)
end

fun foreachp[t](p : Par[t], fn : t -> void) : Par[void]
  p >> fn
end

fun aggregate[t, a, r](p : Par[t], var init : a, fn1 : (a, t) -> a, fn2 : a -> r) : Par[r]
  liftf(reduce(fn1, init, p)) >> fn2
end

fun intersection[t](p1 : Par[t], p2 : Par[t], cmp : (t, t) -> int) : Par[t]
  EMBED (Par[t])
    party_intersection(_ctx, #{p1}, #{p2}, #{cmp}, _enc__type_t);
  END
end

fun distinct[t](p : Par[t], cmp : (t, t) -> int) : Par[t]
  EMBED (Par[t])
    party_distinct(_ctx, #{p}, #{cmp}, _enc__type_t);
  END
end

fun union[t](pl : Par[t], pr : Par[t], cmp : (t, t) -> int) : Par[t]
  distinct(pl ||| pr, cmp)
end

fun app[a, b](p : Par[a -> b], item : a) : Par[b]
  p >> (fun (fn : a -> b) => fn(item))
end

fun pairWith[t, k](p : Par[t], fn : t -> k) : Par[(k, t)]
  p >> (fun (x : t) => (fn(x), x))
end

-- private function.
-- filter out items in the `p` ParT whose key is different from the given key `x`.
-- return a future with the elements that match the key
fun groupParTuples[k, i](x : k, p : Par[(k, i)], cmp : (k, k) -> int) : Fut[(k, Par[i])]
  val closure = fun (acc : (k, Par[i]), elem : (k, i))
                  val accKey = acc.0
                  val p = acc.1
                  val elemKey = elem.0
                  val elemValue = elem.1
                  val equals = cmp(accKey, elemKey)
                  if equals == 0 then
                    (accKey, p ||| liftv(elemValue))
                  else
                    acc
                  end
                end
  reduce(closure, (x, empty[i]()), p)
end

-- private function
-- finds if an element exists in a ParT of tuples
fun findElemInParTuple[k, t](key : k, p : Par[(k, t)], cmp : (k, k) -> int) : Fut[Maybe[t]]
  val closure = fun (acc : Maybe[t], elem : (k, t))
                  val keyElem = elem.0
                  val keyValue = elem.1
                  if cmp(key, keyElem) == 0 then
                     Just(keyValue)
                  else
                     acc
                  end
                end
  reduce(closure, Nothing, p)
end



{-
Group elements of two ParTs based on their keys and joins them according
to their join function. Elements that have no matching key are ignored.

E.g.

```
  val magnus = new Person("Magnus")
  val terry = new Person("Terry")
  val charlotte = new Person("Charlotte")
  val kiko = new Person("Kiko")

  val barley = new Pet("Barley", terry)
  val boots = new Pet("Boots", terry)
  val whiskers = new Pet("Whiskers", charlotte)
  val daisy = new Pet("Daisy", magnus)

  val people = liftv(magnus) ||| liftv(terry) ||| liftv(charlotte) ||| liftv(kiko)
  val pets = liftv(barley) ||| liftv(boots) ||| liftv(whiskers) ||| liftv(daisy)
  val query = groupJoin(people,
                        pets,
                        fun (p : Person) => p.name,
                        fun (p : Pet) => p.owner.name,
                        fun (per : Person, animals : Par[Pet])
                          liftv((per.name, animals >> (fun (p : Pet) => p.name)))
                        end,
                        fun (s1 : String, s2 : String) => s1.compare(s2))

  for elem <- extract(query) do
    match elem with
      case (name, pets) =>
        println("{}:", name)
        for pet <- extract(pets) do
          println("{}", pet)
        end
      end
    end
  end
```

In the example above, the expected output is:

```
  Terry:
  Barley
  Boots
  Charlotte:
  Whiskers
  Magnus:
  Daisy
```

where the person `Kiko` doesn't have any pet and is therefore ignored.

-}

fun groupJoin[t, i, k, r](pt : Par[t], pi : Par[i], tk : t -> k, ik : i -> k,
                          fn : (t, Par[i]) -> Par[r], cmp : (k, k) -> int) : Par[r]
  -- Pair function with their corresponding ParT
  val pkt = pairWith(pt, tk)
  val pki = pairWith(pi, ik)

  -- Get distinct elements
  val pkid = distinct(pki, fun (v : (k, i), u : (k, i))
                             cmp(v.0, u.0)
                           end)

  join(pkid >> (fun (tuple : (k, i))
                  val key = tuple.0
                  -- group values from the same key under the same ParT
                  val groupedPiKeyToPar = groupParTuples(key, pki, cmp)

                  -- fetch only the values from the tuple
                  val groupedPi = join(liftf(groupedPiKeyToPar ~~> (fun (keyParT: (k, Par[i]))
                                                                      keyParT.1
                                                                    end)))

                  -- find if the key from second ParT (from pkdi) exists
                  -- in the pkt ParT and execute function asynchronously
                  -- only if it does exist.
                  val futtkElem = findElemInParTuple(key, pkt, cmp)
                  val fp = futtkElem ~~> fun (tkElem : Maybe[t])
                                           match tkElem with
                                             case Nothing =>
                                               empty[r]()
                                             end
                                             case Just(tkResultVal) =>
                                               fn(tkResultVal, groupedPi)
                                             end
                                           end
                                         end

                  -- the result is an fp, Fut[Par[r]].
                  -- Lift the future to a ParT and flatten the Par[Par[t]] to Par[r]
                  join(liftf(fp))
                end))
end
