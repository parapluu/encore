module Arrow(
    arr,
    first,
    second,
    composition,
    branch,
    combine,
    runArrow,
  )

import ParT

fun arr[a, b](fn : a -> b) : Par[a -> b]
  liftv(fn)
end

-- first :: Arrow a => a b c -> a (b, d) (c, d)
fun first[a, b, c](p : Par[a -> b]) : Par[((a, c)) -> (b, c)]
  val closure = fun (fn : a -> b)
                  liftv(fun (t : (a, c))
                          match t with
                            case (x1, x2) =>
                              (fn(x1), x2)
                            end

                          end
                        end)
                end
  bind(closure, p)
end

-- second :: Arrow a => a b c -> A (d, b) (d, c)
fun second[a, b, c](p : Par[a -> b]) : Par[((c, a)) -> (c, b)]
  val closure = fun (fn : a -> b)
                  liftv(fun (t : (c, a))
                          match t with
                            case (x1, x2) =>
                              (x1, fn(x2))
                            end

                          end
                        end)
                end
  bind(closure, p)
end

-- private function
fun compose[a, b, c](f1 : a -> b, f2 : b -> c) : a -> c
  fun (x : a) => f2(f1(x))
end

--- (>>>) :: Control.Category.Category cat => cat a b -> cat b c -> cat a c
fun composition[a, b, c](p : Par[a -> b], p2 : Par[b -> c]) : Par[a -> c]
  bind(fun (fn : a -> b)
         bind(fun (fn2 : b -> c) => liftv(compose(fn, fn2)), p2)
       end, p)
end

-- (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
fun branch[a, b, c](p : Par[a -> b], p2 : Par[a -> c]) : Par[a -> (b, c)]
  val clos = fun (fn1 : a -> b)
               val clos2 = fun (fn2 : a -> c)
                             liftv(fun (x : a)
                                     (fn1(x), fn2(x))
                                   end)
                           end
               bind(clos2, p2)
             end
  bind(clos, p)
end

-- (***) :: Arrow a => a b c -> a d e -> a (b, d) (c, e)
fun combine[a, b, c, d](p1 : Par[a -> b], p2 : Par[c -> d]) : Par[((a, c)) -> (b, d)]
  val clos = fun (fn1 : a -> b)
               val clos2 = fun (fn2 : c -> d)
                             liftv(fun (t : (a, c))
                                     match t with
                                       case (e1, e2) =>
                                         (fn1(e1), fn2(e2))
                                       end

                                     end
                                   end)
                           end
               bind(clos2, p2)
             end
  bind(clos, p1)
end

-- utility function to lift the item into the arrow
-- and perform function application
fun runArrow[a, b](item : a, p : Par[a -> b]) : Par[b]
  p >> (fun (fn : a -> b) => fn(item))
end
