bundle Regex where

embed
  #include <regex.h>
end

typedef RegexT = embed regex_t end

passive class Regex
  pattern: String
  maxSize: int
  flagICase: bool
  flagNewLine: bool
  pMatch: embed regmatch_t* end  -- private attribute
  regex: RegexT       -- private attribute
  executed: embed char* end

  def Regex_trace(): void {
    embed void
    _enc__passive_String_t* _enc__field_pattern = _this->_enc__field_pattern;
    pony_traceobject((*_ctx), _enc__field_pattern, _enc__trace_String);
    int64_t _enc__field_maxSize = _this->_enc__field_maxSize;

    int64_t _enc__field_flagICase = _this->_enc__field_flagICase;

    int64_t _enc__field_flagNewLine = _this->_enc__field_flagNewLine;
    end
  }


  def init(pattern: String, maxSize: int): void {
    this.pattern = pattern;
    this.maxSize = maxSize;
    this.pMatch = embed (embed regmatch_t* end)
                  regmatch_t *pMatch = encore_alloc(encore_ctx(), sizeof(regmatch_t) * #{maxSize});
                  pMatch;
                  end;
  }

  def icase(): void this.flagICase = true
  def newLine(): void this.flagNewLine = true

  -- compile(): returns `true` if the pattern can be compiled, `false` otherwise.
  def compile(): bool
    let fIc = this.flagICase
        fNl = this.flagNewLine
        pattern = this.pattern.getData()
        regex = this.regex
    in
      embed bool
        bool result = 0;
        if (#{fIc}==1 && #{fNl}==1){
           result = regcomp(&((*_this)._enc__field_regex), #{pattern}, REG_EXTENDED|REG_ICASE|REG_NEWLINE);
        } else if (#{fIc}==1) {
           result = regcomp(&((*_this)._enc__field_regex), #{pattern}, REG_EXTENDED|REG_ICASE);
        } else {
           result = regcomp(&((*_this)._enc__field_regex), #{pattern}, REG_EXTENDED);
        }

        0 == result;
      end

  -- exec(str: String): returns true if the exec method found a match,
  --                    otherwise it returns false (indicates error or no match found)
  def exec(str: String): Maybe bool
    let s = str.getData()
        nmatch = this.maxSize
        pMatch = this.pMatch
        result = 0
    in {
      this.executed = s;
      result = embed int
        regexec(&((*_this)._enc__field_regex), #{s}, #{nmatch}, #{pMatch}, 0);
      end;
      if (embed bool #{result} == REG_NOMATCH; end) then Just false
      else if (result == 0) then Just true
      else Nothing : Maybe bool
    }

  def matches(): int {
    let regex = this.regex in
      embed int
        (int) #{regex}.re_nsub;
      end
  }

  def getAt(i: int): String {
    let pmatch = this.pMatch
        executed = this.executed
    in new String(embed (embed char* end)
        regoff_t match = #{pmatch}[#{i}].rm_eo - #{pmatch}[#{i}].rm_so;
        char *str = encore_alloc(*_ctx, ((size_t) match) + 1);
        strncpy(str, &#{executed}[#{pmatch}[#{i}].rm_so], (size_t) match);
        str;
       end)
  }

  def close(): void {
    let regex = this.regex in
    embed void
      regfree(&#{regex});
    end
  }
